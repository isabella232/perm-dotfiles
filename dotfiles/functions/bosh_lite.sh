#!/bin/bash

target_bosh() {
  green='\033[32m'
  red='\033[31m'
  nc='\033[0m'

  pool_dir=~/workspace/capi-env-pool/bosh-lites/claimed

  pushd ${pool_dir} >/dev/null
    git pull
  popd >/dev/null

  if [ -z "$1" ]; then
    echo -e "${red}Usage: target_bosh <environment>. Valid environments are:${nc}"
    ls ${pool_dir}
  else
    env_file=${pool_dir}/${1}

    if [ -f "$env_file" ]; then
      # shellcheck source=/dev/null
      source "$env_file"
      echo -e "${green}Success!${nc}"
      env_ssh_key_path="$HOME/workspace/capi-env-pool/${1}/bosh.pem"

      if [ ! -f "$env_ssh_key_path" ]; then
        : "${BOSH_GW_PRIVATE_KEY_CONTENTS:?"Need to set BOSH_GW_PRIVATE_KEY_CONTENTS"}"
        echo "$BOSH_GW_PRIVATE_KEY_CONTENTS" > "$env_ssh_key_path"
        chmod 0600 "$env_ssh_key_path"
      fi

      export BOSH_GW_PRIVATE_KEY="$env_ssh_key_path"
    else
      echo -e "${red}Environment '${1}' does not exist. Valid environments are:${nc}"
      ls ${pool_dir}
    fi
  fi
}

function claim_bosh_lite() {
  env_dir=$(
    set -e
    function msg {
      echo -e "$1"
    }
    function realpath {
      echo "$(cd "$(dirname "$1")" && pwd -P)/$(basename "$1")"
    }
    function claim_random_environment() {
      pool="bosh-lites"
      git pull --rebase --quiet
      for f in ./${pool}/unclaimed/*; do
        test -f "$f" || continue
        msg "Claiming $( basename "$f" )..."
        claim_specific_environment "$(basename "$f")"
        return $?
      done
      msg "No unclaimed environment found in $pool"
      return 1
    }
    function claim_specific_environment() {
      env=$1
      file="$(find . -name "${env}")"
      if [[  "$file" == "" ]]; then
        echo "$env" does not exist
        return 1
      fi
      set +e
      file_unclaimed="$(echo "${file}" | grep claim | grep -v unclaim)"
      set -e
      if [[ "$file_unclaimed" ]]; then
        msg "$env" could not be claimed
        return 1
      fi
      newfile="${file//unclaimed/claimed}"
      git mv "$file" "$newfile"
      git add "${newfile}"
    }

    function create_env_dir() {
      msg "Writing out .envrc..."
      env_file="$1"
      env_name="$(basename "${env_file}")"
      mkdir -p "${env_name}"
      green="\033[32m"
      nc="\033[0m"
      # shellcheck source=/dev/null
      source "${env_file}"
      env_ssh_key_path="$HOME/workspace/capi-env-pool/${env_name}/bosh.pem"
      cat << EOF > "${env_name}/.envrc"
#!/bin/bash

source ~/.functions/bosh_lite.sh

# NOTE: this file was auto-generated by 'claim_bosh_lite' alias
target_bosh "${env_name}"
echo -e "\n##################################\n"
echo -e "${green}Some example commands for BOSH + CF${nc}"
default_cmd='bosh deploy ~/workspace/cf-deployment/cf-deployment.yml -v system_domain=\$BOSH_LITE_DOMAIN -o ~/workspace/capi-ci/cf-deployment-operations/use-latest-stemcell.yml -o ~/workspace/capi-ci/cf-deployment-operations/skip-cert-verify.yml -o ~/workspace/cf-deployment/operations/bosh-lite.yml -o ~/workspace/cf-deployment/operations/bypass-cc-bridge.yml'
echo -e "${green}\n## Target this bosh-lite environment ##${nc}"
echo "target_bosh ${env_name}"
echo -e "${green}\n## Create and upload CAPI release ##${nc}"
echo "upload_capi_release"
echo -e "${green}\n## Deploy CF with latest CAPI release ##${nc}"
echo "create_and_deploy"
echo -e "${green}\n## Deploy CF noninteractively with latest CAPI release ##${nc}"
echo "create_and_force_deploy"
echo -e "${green}\n## Connect to this environment psql ##${nc}"
echo "psql_bosh_lite"
echo -e "${green}\n## Deploy CF with defaults ##${nc}"
echo "\${default_cmd}"
echo -e "${green}\n## Target CF API ##${nc}"
echo "cf api https://api.${BOSH_LITE_DOMAIN} --skip-ssl-validation"
echo -e "${green}\n## Target CF API, login as admin ##${nc}"
echo "target_cf"
echo -e "${green}\n## Target CF API, login as admin, and create org and space##${nc}"
echo "bootstrap_cf"
echo -e "${green}\n## Retrieve CF admin password ##${nc}"
echo 'credhub login -s "\$CREDHUB_SERVER" -u "\$CREDHUB_USERNAME" -p "\$CREDHUB_PASSWORD" --skip-tls-validation'
echo "credhub get --name '/bosh-lite/cf/cf_admin_password' --output-json | jq -r '.value'"
echo -e "${green}\n## Unclaim this environment ##${nc}"
echo "unclaim_bosh_lite ${env_name}"
echo -e "${green}\n## Short circuit CC traffic into local process ##${nc}"
echo "~/workspace/capi-release/src/cloud_controller_ng/scripts/short-circuit-cc"
echo -e "${green}\n## Print this help text ##${nc}"
echo ". .envrc"
echo -e "\n##################################\n"
EOF
      git add "${env_name}"
    }

    function commit_and_push() {
      git ci -n --quiet --message "manually claim ${env} on ${HOSTNAME} [nostory]" --no-verify
      msg "Pushing reservation to $( basename "$PWD" )..."
      git push --quiet
    }

    >&2 cd ~/workspace/capi-env-pool
    >&2 claim_random_environment
    env_file="$(realpath "$newfile")"
    >&2 create_env_dir "${env_file}"
    >&2 commit_and_push
    echo "$PWD/$(basename "${env_file}")"
  )

  # shellcheck disable=2181
  if [[ "$?" == 0 ]]; then
    direnv allow "${env_dir}"
    echo "Changing directory to '${env_dir}'..."
    cd "${env_dir}"
  fi
}

function unclaim_bosh_lite() {

  # ensures we don't remove the current working directory
  if [[ "$PWD" == *capi-env-pool* ]]; then
    cd "$HOME/workspace/capi-env-pool"
  fi
  (
    set -e
    cd ~/workspace/capi-env-pool

    working_pool="bosh-lites"
    broken_pool="broken-bosh-lites"

    if [ $# -eq 0 ]; then
      echo "Usage: $0 env_name"
      return 1
    fi

    git pull -r --quiet

    function mark_broken {
      env=$1
      file="$(find "${working_pool}" -name "${env}")"

      if [[ "$file" == "" ]]; then
        echo "$env does not exist in ${working_pool}"
        return 1
      fi

      read -r "?Hit enter to release ${env} "

      git mv "${file}" "${broken_pool}/unclaimed/"
      if [ -d "${env}" ]; then
        git rm -rf "${env}" && rm -rf "${env}"
      fi

      # trigger destroy-bosh-lite job
      date +%s >| .trigger-bosh-lites-destroy && git add .trigger-bosh-lites-destroy

      git ci -n --quiet -m"releasing $env on ${HOSTNAME} [nostory]" --no-verify
      echo "Pushing the release commit to $( basename "$PWD" )..."
      git push --quiet
    }

    for env in "$@"; do
      mark_broken "${env}"
    done
  )

  unset BOSH_CA_CERT BOSH_CLIENT BOSH_CLIENT_SECRET BOSH_ENVIRONMENT \
    BOSH_GW_USER BOSH_GW_HOST BOSH_LITE_DOMAIN BOSH_GW_PRIVATE_KEY_CONTENTS \
    BOSH_GW_PRIVATE_KEY

  echo "Done"
}

function target_ci_bosh_lite() {
  local env_name
  local temp_dir

  env_name="${1}"
  temp_dir="$(mktemp -d)"
  env_path="${temp_dir}/env.sh"

  write_bosh_target "$env_name" "$temp_dir" "$env_path"
  exit_code="$?"

  if [[ "$exit_code" != "0" ]]; then
    echo "Failed :("
    return "$exit_code"
  fi

  # shellcheck source=/dev/null
  source "$env_path"
}

function write_bosh_target() (
  set -eux
  set -o pipefail

  local temp_dir
  local env_name
  local env_path
  local creds_path

  local bosh_ca_cert
  local bosh_admin_username
  local bosh_admin_password
  local bosh_ip
  local bosh_deployment
  local bosh_gw_user
  local bosh_gw_host
  local bosh_gw_private_key
  local bosh_gw_private_key_contents
  local bosh_lite_domain

  local uaa_ca

  local credhub_ca
  local credhub_server
  local credhub_username
  local credhub_password

  local cf_api
  local cf_username
  local cf_password

  env_name="${1}"
  temp_dir="${2}"
  env_path="${3}"
  creds_path="${temp_dir}/creds.yml"

  : "${env_name:?"Usage: \`target_ci_bosh_lite <env_name>\`"}"

  echo "Targeting environment ${env_name}..."

  gsutil cp "gs://perm-environments/director-state/${env_name}/creds.yml" "$creds_path" > /dev/null 2>&1

  bosh_lite_domain="${env_name}.perm.cf-app.com"
  cf_api="api.${bosh_lite_domain}"
  bosh_ip="$(dig +short "${cf_api}")"

  bosh_ca_cert="$(bosh interpolate "$creds_path" --path /default_ca/ca)"
  uaa_ca="${bosh_ca_cert}"

  bosh_admin_username="admin"
  bosh_admin_password="$(bosh interpolate "$creds_path" --path /admin_password)"
  bosh_deployment="cf"
  bosh_gw_user="jumpbox"
  bosh_gw_host="$bosh_ip"
  bosh_gw_private_key="${TMPDIR:-/tmp}/${env_name}.pem"
  bosh_gw_private_key_contents="$(bosh interpolate "$creds_path" --path /jumpbox_ssh/private_key)"

  credhub_ca="$(bosh interpolate "$creds_path" --path /credhub_ca/ca)"
  credhub_server="https://${bosh_ip}:8844"
  credhub_client="credhub-admin"
  credhub_secret="$(bosh interpolate "$creds_path" --path /credhub_admin_client_secret)"

  CREDHUB_CA_CERT="${credhub_ca}\n${uaa_ca}" \
    CREDHUB_SERVER="$credhub_server" \
    CREDHUB_CLIENT="$credhub_client" \
    CREDHUB_SECRET="$credhub_secret" \
    login_to_credhub

  cf_username="admin"
  cf_password="$(credhub get -n /bosh-lite/cf/cf_admin_password --output-json | jq -r -e .value)"

  echo "$bosh_gw_private_key_contents" > "$bosh_gw_private_key"
  chmod 600 "$bosh_gw_private_key"

  cat << EOF > "$env_path"
export BOSH_CA_CERT="$bosh_ca_cert"
export BOSH_CLIENT="$bosh_admin_username"
export BOSH_CLIENT_SECRET="$bosh_admin_password"
export BOSH_ENVIRONMENT="$bosh_ip"
export BOSH_DEPLOYMENT="$bosh_deployment"
export BOSH_GW_USER="$bosh_gw_user"
export BOSH_GW_HOST="$bosh_gw_host"
export BOSH_GW_PRIVATE_KEY="$bosh_gw_private_key"
export BOSH_LITE_DOMAIN="$bosh_lite_domain"

function cf_login() {
  cf api "$cf_api" --skip-ssl-validation
  cf login -u "${cf_username}" -p "${cf_password}"
}
EOF

  echo -e "\033[32m\n## Target CF API and login as admin ##\033[0m"
  echo "cf_login"
)
